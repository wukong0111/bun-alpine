import { db } from '../database/database';
import { gzipSync } from 'zlib';

export interface BackupMetadata {
  timestamp: string;
  version: string;
  nodeEnv: string;
  databaseSize: number;
  tableCount: number;
  recordCount: {
    users: number;
    languages: number;
    votes: number;
    user_monthly_votes: number;
  };
}

export async function createDatabaseBackup(): Promise<{
  data: Buffer;
  metadata: BackupMetadata;
  filename: string;
}> {
  try {
    // Crear SQL dump completo
    const sqlDump = await generateSQLDump();
    
    // Obtener metadata
    const metadata = await getBackupMetadata();
    
    // Crear contenido del backup
    const backupContent = {
      metadata,
      sqlDump,
      createdAt: new Date().toISOString()
    };
    
    // Comprimir el backup
    const jsonContent = JSON.stringify(backupContent, null, 2);
    const compressedData = gzipSync(Buffer.from(jsonContent, 'utf-8'));
    
    // Nombre del archivo
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `backup-${timestamp}.sql.gz`;
    
    return {
      data: compressedData,
      metadata,
      filename
    };
  } catch (error) {
    console.error('Error creating database backup:', error);
    throw new Error('Failed to create database backup');
  }
}

async function generateSQLDump(): Promise<string> {
  // Obtener esquema de todas las tablas
  const tables = db.prepare(`
    SELECT name FROM sqlite_master 
    WHERE type='table' 
    AND name NOT LIKE 'sqlite_%'
    ORDER BY name
  `).all() as { name: string }[];
  
  let sqlDump = '';
  
  // Agregar header
  sqlDump += `-- Database backup created on ${new Date().toISOString()}\n`;
  sqlDump += `-- Generated by Bun Alpine Ranking System\n\n`;
  
  // Para cada tabla
  for (const table of tables) {
    const tableName = table.name;
    
    // Obtener esquema de la tabla
    const schema = db.prepare(`
      SELECT sql FROM sqlite_master 
      WHERE type='table' AND name = ?
    `).get(tableName) as { sql: string };
    
    if (schema) {
      sqlDump += `-- Table: ${tableName}\n`;
      sqlDump += `DROP TABLE IF EXISTS ${tableName};\n`;
      sqlDump += `${schema.sql};\n\n`;
      
      // Obtener datos de la tabla
      const rows = db.prepare(`SELECT * FROM ${tableName}`).all();
      
      if (rows.length > 0) {
        // Obtener nombres de columnas
        const columns = Object.keys(rows[0] as Record<string, any>);
        const columnNames = columns.join(', ');
        
        sqlDump += `-- Data for table: ${tableName}\n`;
        
        for (const row of rows) {
          const values = columns.map(col => {
            const value = (row as Record<string, any>)[col];
            if (value === null) return 'NULL';
            if (typeof value === 'string') return `'${value.replace(/'/g, "''")}'`;
            return value;
          });
          
          sqlDump += `INSERT INTO ${tableName} (${columnNames}) VALUES (${values.join(', ')});\n`;
        }
        
        sqlDump += '\n';
      }
    }
  }
  
  // Agregar índices
  const indexes = db.prepare(`
    SELECT sql FROM sqlite_master 
    WHERE type='index' 
    AND name NOT LIKE 'sqlite_%'
    AND sql IS NOT NULL
    ORDER BY name
  `).all() as { sql: string }[];
  
  if (indexes.length > 0) {
    sqlDump += `-- Indexes\n`;
    for (const index of indexes) {
      sqlDump += `${index.sql};\n`;
    }
    sqlDump += '\n';
  }
  
  return sqlDump;
}

async function getBackupMetadata(): Promise<BackupMetadata> {
  // Obtener estadísticas de la base de datos
  const stats = {
    users: db.prepare('SELECT COUNT(*) as count FROM users').get() as { count: number },
    languages: db.prepare('SELECT COUNT(*) as count FROM languages').get() as { count: number },
    votes: db.prepare('SELECT COUNT(*) as count FROM votes').get() as { count: number },
    user_monthly_votes: db.prepare('SELECT COUNT(*) as count FROM user_monthly_votes').get() as { count: number }
  };
  
  // Obtener tamaño de la base de datos
  const dbSize = (await Bun.file(process.env.DATABASE_PATH || './src/database/ranking.db').size) || 0;
  
  // Contar tablas
  const tableCount = db.prepare(`
    SELECT COUNT(*) as count FROM sqlite_master 
    WHERE type='table' AND name NOT LIKE 'sqlite_%'
  `).get() as { count: number };
  
  return {
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    nodeEnv: process.env.NODE_ENV || 'development',
    databaseSize: dbSize,
    tableCount: tableCount.count,
    recordCount: {
      users: stats.users.count,
      languages: stats.languages.count,
      votes: stats.votes.count,
      user_monthly_votes: stats.user_monthly_votes.count
    }
  };
}